#!/usr/bin/env bash
# This scripts generates:
# $PROJECT_DIR/data/$1/
# └──  response.html
# $PROJECT_DIR/parsers/user_parsers/$1/
# ├──  __init__.py
# ├──  config.py
# ├──  constants.py
# └──  parser.py
#
# And starts a code editor at a certain position (line and column) of a file
# file: $PROJECT_DIR/parsers/user_parsers/$1/constants.py


# Error codes (from /usr/include/asm-generic/errno-base.h)
E2BIG=7
EINVAL=22
E2SMALL=64

# Usage
SCRIPT_NAME=$0
USAGE=$(cat << EOT

This script requires exactly one argument DIRECTORY_NAME.

RETURN CODES
    The script has the following return codes:

    0   success
    $E2BIG  Argument list too long
    $EINVAL Invalid argument
    $E2SMALL Argument list too short

USAGE
    $(echo -e "\033[0;33m$SCRIPT_NAME <DIRECTORY_NAME>\033[0m")
EOT
)

# Exit conditions
if [ ${#} -lt 1 ] ; then
    printf '\033[1;31mYou must pass a directory name to create a template!\033[0m\n'
    printf '%s\n\n' "${USAGE}"
    exit $E2SMALL
fi
if [ "${1}" = "-h" ] || [ "${1}" = "--help" ] ; then
    printf '%s\n\n' "${USAGE}"
    exit 0
fi
if [ ${#} -gt 1 ] ; then
    printf '\033[1;31mYou must pass only one argument!\033[0m\n'
    printf '%s\n\n' "${USAGE}"
    exit $E2BIG
fi

DIR_NAME=$1
PROJECT_DIR=$PROJECT_DIR
PARSER_TEMPLATE=$PROJECT_DIR/parsers/user_parsers/$DIR_NAME


# Generating parser template
mkdir "$PARSER_TEMPLATE"
touch "$PARSER_TEMPLATE"/{__init__,config,constants,parser}.py

cat <<EOT >> "$PARSER_TEMPLATE"/__init__.py
#!/usr/bin/env python
"""# TODO: docsting."""
from .parser import main
EOT

cat <<EOT >> "$PARSER_TEMPLATE"/config.py
"""# TODO: docstring."""
EOT

cat <<EOT >> "$PARSER_TEMPLATE"/constants.py
"""# TODO: docsting."""

URL = 'https://$DIR_NAME.com' # FIXME: if needed    <---

PARSED_DIR = '$(basename "$PROJECT_DIR")/data/$DIR_NAME'
EOT

cat <<EOT >> "$PARSER_TEMPLATE"/parser.py
#!/usr/bin/env python
"""# TODO: docsting."""

import requests as _requests
from bs4 import BeautifulSoup as _BeautifulSoup

if is_script := __name__ == '__main__':
    __package__ = 'parsers.user_parsers.$DIR_NAME'

    def fix_path():
        '''Fix sys.path and die.'''
        from sys import path
        path.insert(0, path[0] + 3 * '/..')
        global fix_path; del fix_path  # noqa: E702
    fix_path()

# 'Parsers' imports
from ...constants import ConstantStorage as _ConstantStorage
from ...handlers import handle_data as _handle_data
from ...handlers import HandledData as _HandledData
from ...imports import snoop as _snoop

# '$DIR_NAME' template local imports
from .constants import URL
from .constants import URL_DPI
from .constants import PARSED_DIR

URL = URL or None


# @_snoop
def _load_page(url: str, **request_kwargs) -> _HandledData:
    """Get the page and return HandledData object"""
    response = _requests.get(url, **request_kwargs)
    # _handle_data() automatically saves the loaded page
    # IN $PROJECT_DIR$DIRNAME.{html or json}
    return _handle_data(response, PARSED_DIR)


# @_snoop
def _parse(raw: _HandledData, parser: str = _ConstantStorage.PARSE.PARSER):
    """Fetch the data from \`raw.data\`"""
    result = None
    if raw.is_json:
        result = ...
    else:
        soup = _BeautifulSoup(raw.data, parser or input('Enter bs4 parser: '))
        result = ...
    return result


# @_snoop
def _save_result(data) -> None:
    """# TODO: docstring."""
    pass


#@_snoop
def main(url: str = None) -> None:
    """Parse and save"""
    handled = _load_page(url or URL or input('Enter URL: '))
    parsed = _parse(handled)
    _save_result(parsed)


if is_script:
    print("\033[0;32mHello from $DIR_NAME.parser!\033[0m")
    main()
EOT

# Generating parsed data structure
PARSED_DATA_TEMPLATE=$PROJECT_DIR/data/$DIR_NAME
mkdir "$PARSED_DATA_TEMPLATE"
touch "$PARSED_DATA_TEMPLATE"/response.html

printf "\n\033[0;33mTemplate '%s' created successfully.\033[0m\n\n" "${DIR_NAME}"
tree -p "$PARSER_TEMPLATE"


# Open $PROJECT_DIR/parsers/user_parsers/$1/constants.py
# to fix a first-level domain of URL constant
CONSTANTS_URL="$PROJECT_DIR/parsers/user_parsers/$DIR_NAME/constants.py"
# Define a magic number 20
# A length of "URL = 'https://.com" + 1 (because the cursor sets before last char)
declare -i CURSOR_COLUMN_POSITION=$((${#DIR_NAME} + 20))
# Time to show on the terminal outs
sleep 2
# and start a code editor <file>:<line>:<column>
# with the VSCode or Vim
if command -v code >/dev/null; then
    code --goto "$CONSTANTS_URL":3:"$CURSOR_COLUMN_POSITION"
else
    vim "+call cursor(3, $CURSOR_COLUMN_POSITION)" "$CONSTANTS_URL"
fi
